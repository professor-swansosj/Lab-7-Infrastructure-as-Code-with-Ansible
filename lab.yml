# ==========================================
# Course: Software Defined Networking
# Module: Infrastructure as Code with Ansible
# Purpose: Hands on activity for using Ansible to manage network devices
# Filename: lab.yml
# Author: Sheldon Swanson
# Version: 1.0
# Created: 10/2025
# Updated: 10/2025
# Notes: Parsers ignore these comments.
# ==========================================
title: "Lab 7 — Infrastructure as Code with Ansible"
course: "Software Defined Networking"
module: "Network Automation Fundamentals"
lab_number: 7
time_estimate: "120–150 minutes"

#====================================================
#   ____  _____    _    ____  __  __ _____
#  |  _ \| ____|  / \  |  _ \|  \/  | ____|
#  | |_) |  _|   / _ \ | | | | |\/| |  _|
#  |  _ <| |___ / ___ \| |_| | |  | | |___
#  |_| \_\_____/_/   \_\____/|_|  |_|_____|
#====================================================

repo_tree:
  enabled: true
  max_depth: 3
  ignore:
    - ".git"
    - ".github"
    - "_template"
    - "_render"
    - "__pycache__"
    - ".venv"
    - "venv"
    - "node_modules"
    - ".vscode"
    - ".idea"
    - "*.pyc"
    - "logs"
    - "screens"

readme_topic:
  - title: "Introduction to Ansible"
    content: |
      Ansible is an open-source automation tool that simplifies the management and configuration of
      network devices and IT infrastructure. It uses a simple, human-readable language (YAML) to
      describe automation tasks in playbooks. Ansible operates in an agentless manner, connecting
      to devices over SSH or APIs, making it easy to deploy and manage configurations across
      multiple devices simultaneously.

      Key features of Ansible include:
      - **Idempotency**: Ensures that applying the same configuration multiple times results in the
        same state without unintended changes.
      - **Extensibility**: Supports a wide range of modules for different platforms, including
        network devices from vendors like Cisco, Juniper, and Arista.
      - **Inventory Management**: Allows users to define groups of hosts and their variables in
        inventory files.
      - **Templates**: Uses Jinja2 templating to create dynamic configuration files based on
        variables.
      - **Playbooks**: YAML files that define a series of tasks to be executed on specified hosts.

      Ansible is widely used in network automation for tasks such as configuration management,
      software updates, and network provisioning, enabling network engineers to automate repetitive
      tasks and improve operational efficiency.

  - title: "Ansible Project Structure"
    content: | 
      An Ansible project typically follows a structured directory layout to organize playbooks,
      inventories, variables, templates, and other related files. A common structure includes:

      This structure helps maintain clarity and organization, making it easier to manage complex
      automation tasks across multiple devices and environments.

    code_block:
      language: "bash"
      code: |
        ansible.cfg               # Configuration file for Ansible settings
        inventory.yml             # Inventory file defining hosts and groups
        group_vars/               # Directory for group-specific variables
            all.yml               # Variables applied to all hosts
            routers.yml           # Variables specific to router group
        host_vars/                # Directory for host-specific variables
            router1.yml           # Variables specific to router1
        templates/                # Directory for Jinja2 templates
            vlans.j2              # Template for VLAN configuration
            loopbacks.j2          # Template for Loopback interfaces
        playbooks/                # Directory for Ansible playbooks
            test_connectivity.yml  # Playbook to test connectivity and gather facts
            configure_vlans.yml    # Playbook to configure VLANs
            configure_loopbacks.yml # Playbook to configure Loopback interfaces
            backup_config.yml       # Playbook to backup device configurations
            deploy_all.yml          # Master playbook to run all tasks
        configs/                  # Directory for generated configuration files
        backups/                  # Directory for device configuration backups
        logs/                     # Directory for log files

    code_notes: |
      - `ansible.cfg`: Configures Ansible settings such as inventory location and callback plugins.
      - `inventory.yml`: Defines the network devices to be managed, organized into groups.
      - `group_vars/`: Contains YAML files with variables that apply to specific groups of hosts.
      - `host_vars/`: Contains YAML files with variables that apply to individual hosts.
      - `templates/`: Stores Jinja2 templates used to generate device configurations dynamically.
      - `playbooks/`: Contains YAML files that define the automation tasks to be executed on the hosts.
      - `configs/`: Directory where rendered configuration files from templates are stored.
      - `backups/`: Directory for storing backups of device configurations, typically with timestamps.
      - `logs/`: Directory for log files that capture the output and status of playbook executions.

  - title: "The Ansible Configuration File (ansible.cfg)"
    content: |
      The `ansible.cfg` file is the main configuration file for Ansible, allowing users to customize
      various settings that affect how Ansible operates. It can be placed in the project root,
      user's home directory, or system-wide. Key sections and options include:

      - **[defaults]**: Contains general settings such as inventory file location, remote user,
        and callback plugins.
      - **[privilege_escalation]**: Configures settings for privilege escalation methods like sudo.
      - **[ssh_connection]**: Manages SSH connection parameters, including control paths and timeouts.
      - **[paramiko_connection]**: Settings specific to Paramiko SSH connections.
      - **[logging]**: Defines log file location and format for Ansible's logging output.

      Example `ansible.cfg` content:

    code_block:
      language: "ini"
      code: |
        [defaults]
        inventory = ./inventory.yml
        host_key_checking = False
        callback_whitelist = yaml # Enables YAML output for better readability
        [privilege_escalation]
        become = True
        become_method = enable
        become_user = root
        [ssh_connection]
        control_path = %(directory)s/%%h-%%r
        [logging]
        log_path = ./logs/ansible.log
        log_level = info
    code_notes: |
      - `inventory`: Specifies the path to the inventory file.
      - `host_key_checking`: Disables SSH host key checking for easier connectivity to new hosts.
      - `callback_whitelist`: Enables specific callback plugins, such as YAML for cleaner output.
      - `become`, `become_method`, `become_user`: Configure privilege escalation settings.
      - `control_path`: Defines the SSH control path for connection reuse.
      - `log_path`, `log_level`: Set the location and verbosity of Ansible logs.

  - title: "The Inventory File (inventory.yml)"
    content: |
      The `inventory.yml` file is a crucial component of Ansible, as it defines the hosts and groups
      of hosts on which automation tasks will be executed. The inventory can be static (defined in
      a YAML file) or dynamic (generated by an external script or plugin). Key elements include:

      - **Hosts**: Individual machines or devices managed by Ansible, identified by their IP address
        or hostname.
      - **Groups**: Collections of hosts that share common characteristics, allowing for easier
        management and targeting of tasks.
      - **Variables**: Host-specific or group-specific variables that customize the behavior of
        playbooks and roles.

      Example `inventory.yml` content:

    code_block:
      language: "yaml"
      code: |
        all:
          children:
            switches:
              hosts:
                switch1:
                  ansible_host: 192.0.2.1
                  ansible_user: admin
                  ansible_password: password
                switch2:
                  ansible_host: 192.0.2.2
                  ansible_user: admin
                  ansible_password: password
            routers:
              hosts:
                router1:
                  ansible_host: 192.0.2.3
                  ansible_user: admin
                  ansible_password: password
                router2:
                  ansible_host: 192.0.2.4
                  ansible_user: admin
                  ansible_password: password
    code_notes: |
      - `all`: The top-level group that includes all hosts.
      - `children`: Defines sub-groups within the inventory.
      - `hosts`: Lists individual hosts and their connection details.
      - `ansible_host`, `ansible_user`, `ansible_password`: Connection parameters for each host.

  - title: "Host Variables `host_vars/`"
    content: |
      The `host_vars/` directory is used to define variables that are specific to individual hosts.
      This allows for greater customization and flexibility in playbooks and roles. Each file in
      this directory should be named after the corresponding host and contain valid YAML.

      Example `host_vars/switch1.yml` content:

    code_block:
      language: "yaml"
      code: |
        ansible_host: 192.0.2.1
        ansible_user: admin
        ansible_password: password
    code_notes: |
      - Each file in `host_vars/` corresponds to a specific host.
      - Variables defined here override those in the inventory file.
      - This is useful for host-specific configurations or credentials.

  - title: "Group Variables `group_vars/`"
    content: |
      The `group_vars/` directory is used to define variables that are specific to groups of hosts.
      This allows for easier management of common settings across multiple hosts. Each file in
      this directory should be named after the corresponding group and contain valid YAML.

      Example `group_vars/switches.yml` content:

    code_block:
      language: "yaml"
      code: |
        ansible_host: 192.0.2.1
        ansible_user: admin
        ansible_password: password
    code_notes: |
      - Each file in `group_vars/` corresponds to a specific group.
      - Variables defined here override those in the inventory file.
      - This is useful for group-specific configurations or credentials.

  - title: "Jinja2 Templates"
    content: |
      Jinja2 is a powerful templating engine used in Ansible to create dynamic configuration files
      based on variables. Templates are stored in the `templates/` directory and typically have a
      `.j2` file extension. They allow for the inclusion of logic, loops, and conditionals to
      generate configurations tailored to specific hosts or groups.

      Example `templates/switch_config.j2` content:

    code_block:
      language: "jinja2"
      code: |
        hostname {{ inventory_hostname }}
        interface Vlan{{ vlan_id }}
          ip address {{ ip_address }} {{ subnet_mask }}
        !
        router ospf 1
          network {{ network }} area 0
        !
    code_notes: |
      - `{{ }}`: Used to insert variables into the template.
      - `{% %}`: Used for control structures like loops and conditionals.
      - Templates can be rendered using the `template` module in playbooks to generate
        configuration files that are then applied to devices.

  - title: "Ansible Galaxy Collections"
    content: |
      Ansible Galaxy is a repository for Ansible roles and collections, which are pre-packaged
      sets of modules, plugins, and roles that extend Ansible's functionality. Collections are
      particularly useful for managing specific platforms or technologies, such as network devices.

      To use a collection, you first need to install it using the `ansible-galaxy` command. For
      example, to install the Cisco IOS collection, you would run:

      ```bash
      ansible-galaxy collection install cisco.ios
      ```

      Once installed, you can use the modules provided by the collection in your playbooks.
      For example, the `cisco.ios.ios_config` module can be used to manage configurations on
      Cisco IOS devices.

      Example playbook snippet using a collection module:

    code_block:
      language: "yaml"
      code: |
        - name: Configure VLANs on Cisco IOS devices
          hosts: switches
          gather_facts: no
          tasks:
            - name: Apply VLAN configuration
              cisco.ios.ios_config:
                lines:
                  - vlan {{ item.id }}
                  - name {{ item.name }}
                with_items: "{{ vlans }}"
    code_notes: |
      - Collections group related modules and plugins for specific platforms.
      - Using collections simplifies playbook development by providing ready-to-use functionality.
      - Always check for the latest version of a collection to ensure compatibility and access to
        new features.


#========================================================================
#
#   ___ _   _ ____ _____ ____  _   _  ____ _____ ___ ___  _   _ ____
#  |_ _| \ | / ___|_   _|  _ \| | | |/ ___|_   _|_ _/ _ \| \ | / ___|
#   | ||  \| \___ \ | | | |_) | | | | |     | |  | | | | |  \| \___ \
#   | || |\  |___) || | |  _ <| |_| | |___  | |  | | |_| | |\  |___) |
#  |___|_| \_|____/ |_| |_| \_\\___/ \____| |_| |___\___/|_| \_|____/
#
#========================================================================
# LAB 7 — INFRASTRUCTURE AS CODE WITH ANSIBLE (IOS-XE: Cat8k + Cat9k)
# Software Defined Networking • Florida State College at Jacksonville
# Worth 75 points

# OBJECTIVES
objectives:
  - "Create a complete Ansible project scaffold for network automation."
  - "Use inventory, group_vars, and host_vars to model multiple IOS-XE devices."
  - "Author two Jinja2 templates; render per-device configs from group and host data."
  - "Run dry-run (check mode), deploy changes, and verify with post-checks."
  - "Capture artifacts (rendered configs, diffs, post-check outputs) and log markers for grading."
  - "Demonstrate idempotency: a second run makes no changes."

# PREREQUISITES
python_version: "3.11"
accounts: ["GitHub", "Cisco DevNet"]
devices:
  - "Cisco DevNet Always-On Catalyst 8000v (IOS-XE)"
  - "Cisco DevNet Always-On Catalyst 9k (IOS-XE)"

prereq:
  - "Ansible basics (inventory, playbooks, modules, check mode)."
  - "YAML + Jinja2 templating."
  - "Network CLI fundamentals (SSH to IOS-XE)."
  - "GitHub Classroom workflow (clone, commit, push, PR)."
  - "Credentials for both sandboxes (do NOT hardcode in repo)."

# OVERVIEW
overview: >
  You will build a real Ansible IaC project for two IOS-XE devices (Cat8k and Cat9k). Create a proper
  scaffold (inventory, ansible.cfg, group_vars, host_vars, templates, playbooks). Define some loopback
  interfaces in group_vars (shared) and some in host_vars (device-specific), render configs from two
  Jinja2 templates, validate with check mode, then deploy and post-check. Save rendered configs, dry-run
  diffs, and post-check command outputs to the repo. Ensure a final idempotency run reports no changes.

# SETUP
before_you_begin: >
  Open the dev container. Install collections with Ansible Galaxy. Verify connectivity to both devices
  (SSH reachable). Ensure you can write to `data/` and `logs/`.

# RESOURCES
resources:
  - { title: "Ansible Documentation", url: "https://docs.ansible.com/" }
  - { title: "cisco.ios Ansible Collection", url: "https://docs.ansible.com/ansible/latest/collections/cisco/ios/" }
  - { title: "ansible.netcommon Collection", url: "https://docs.ansible.com/ansible/latest/collections/ansible/netcommon/" }
  - { title: "Jinja2 Templates", url: "https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_templating.html" }
  - { title: "Check Mode & Idempotency", url: "https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html#check-mode" }

# DELIVERABLES
deliverables:
  - "Ansible project scaffold: `ansible.cfg`, `inventories/`, `group_vars/`, `host_vars/`, `playbooks/`, `templates/`, `requirements.yml`."
  - "`group_vars/all.yml` (shared settings + shared loopbacks), optional group files (e.g., `group_vars/iosxe.yml`)."
  - "`host_vars/cat8k.yml` and `host_vars/cat9k.yml` (device-specific loopbacks and facts)."
  - "Two Jinja2 templates: `templates/base.j2` and `templates/loopbacks.j2`."
  - "Rendered configs under `data/rendered/<inventory_hostname>.cfg`."
  - "Dry-run diffs under `data/dryrun/<inventory_hostname>.diff`."
  - "Post-check outputs under `data/postcheck/<inventory_hostname>.txt`."
  - "`logs/lab7.log` with required markers."
  - "Pull request open to `main` with all artifacts committed."

# STEPS
steps:
  - title: "Clone the Repository"
    goal: "Get your starter locally."
    actions: |
      Clone your GitHub Classroom repo and `cd` into it. Create `data/{rendered,dryrun,postcheck}/`,
      `logs/`, and `playbooks/`, `templates/`, `inventories/`, `group_vars/`, `host_vars/` as needed.
      Initialize the log: `echo 'LAB7_START' >> logs/lab7.log`
    done_when: |
      - Folders exist and `LAB7_START` recorded.
    log_marker: "LAB7_START"

  - title: "Dev Container & Collections"
    goal: "Standardize the toolchain."
    actions: |
      Reopen in container. Create `requirements.yml` with `cisco.ios` and `ansible.netcommon`.
      Run: `ansible-galaxy collection install -r requirements.yml`
      Record versions with `ansible --version` and log:
        - `[STEP 2] Dev Container Started`
        - `GALAXY_OK: cisco.ios`
        - `GALAXY_OK: ansible.netcommon`
    done_when: |
      - Collections installed; Ansible available.
    log_marker: "[STEP 2] Dev Container Started, GALAXY_OK: cisco.ios, GALAXY_OK: ansible.netcommon"

  - title: "Project Scaffold & ansible.cfg"
    goal: "Create a clean, reproducible layout."
    actions: |
      Write `ansible.cfg` with defaults:
        - inventory = inventories/inventory.yml
        - host_key_checking = False
        - retry_files_enabled = False
        - stdout_callback = yaml
      Log `PROJECT_SCAFFOLD_OK`.
    done_when: |
      - `ansible.cfg` present and points to your inventory.
    log_marker: "PROJECT_SCAFFOLD_OK"

  - title: "Inventory for Two Devices"
    goal: "Define Cat8k and Cat9k with groups."
    actions: |
      Create `inventories/inventory.yml` using YAML inventory (e.g., group `iosxe`).
      Each host should set:
        - ansible_host
        - ansible_network_os: cisco.ios.ios
        - ansible_connection: network_cli
        - ansible_user / password via env or prompt (not committed)
      Log `INVENTORY_OK`.
    done_when: |
      - `ansible-inventory --list` shows both hosts.
    log_marker: "INVENTORY_OK"

  - title: "Group Vars & Host Vars"
    goal: "Model shared vs device-specific data."
    actions: |
      In `group_vars/all.yml`, define:
        - `domain_name`, `logging_server`, and a list `loopbacks_shared` (e.g., Loopback10, Loopback11).
      In `host_vars/cat8k.yml` and `host_vars/cat9k.yml`, define:
        - `hostname`, and a list `loopbacks_host` (device-specific interfaces, e.g., Loopback100/101).
      Log `VARS_OK`.
    done_when: |
      - Variables load without errors: `ansible-inventory --graph` works.
    log_marker: "VARS_OK"

  - title: "Two Templates (Jinja2)"
    goal: "Separate baseline from interfaces."
    actions: |
      Create:
        - `templates/base.j2` (hostname, domain, banner, logging, etc.)
        - `templates/loopbacks.j2` (renders both `loopbacks_shared` and `loopbacks_host`)
      Keep templates idempotent (no duplicate interface creation). Log `TEMPLATES_OK`.
    done_when: |
      - Templates render without exceptions using `ansible -m template` (delegate_to localhost).
    log_marker: "TEMPLATES_OK"

  - title: "Render Configs Locally"
    goal: "Materialize per-device configs for review."
    actions: |
      Create `playbooks/render.yml` that uses the `template` module with `delegate_to: localhost` to
      produce `data/rendered/{{ inventory_hostname }}.cfg` by combining base and loopback templates
      (you can assemble via `set_fact` + `copy`, or render two files and concatenate).
      Run: `ansible-playbook playbooks/render.yml`
      Log `RENDER_OK:<host>` for each device.
    done_when: |
      - `data/rendered/cat8k.cfg` and `data/rendered/cat9k.cfg` exist and include both shared and host loopbacks.
    log_marker: "RENDER_OK"

  - title: "Dry-Run (Check Mode)"
    goal: "Preview changes safely."
    actions: |
      Create `playbooks/deploy.yml` using `cisco.ios.ios_config` to push rendered snippets.
      Run with `--check` and capture diff to `data/dryrun/<host>.diff` (use `--diff`).
      Log `DRYRUN_OK`.
    done_when: |
      - Diff files exist for both devices and show intended changes.
    log_marker: "DRYRUN_OK"

  - title: "Deploy & Post-Check"
    goal: "Apply configuration and verify."
    actions: |
      Run `ansible-playbook playbooks/deploy.yml` (no `--check`).
      Then run `playbooks/postcheck.yml` using `cisco.ios.ios_command` to collect:
        - `show ip interface brief | include Loopback`
        - `show running-config | section Loopback`
      Save outputs to `data/postcheck/<host>.txt`. Log `DEPLOY_OK` and `POSTCHECK_OK`.
    done_when: |
      - Loopbacks appear in post-check outputs for both devices.
    log_marker: "DEPLOY_OK, POSTCHECK_OK"

  - title: "Idempotency Run"
    goal: "Second apply should report no changes."
    actions: |
      Re-run `ansible-playbook playbooks/deploy.yml` and confirm `changed=0` for all tasks.
      Append `IDEMPOTENT_OK` to the log if no changes were required.
    done_when: |
      - Idempotent run shows zero changes.
    log_marker: "IDEMPOTENT_OK"

  - title: "Finalize & Submit"
    goal: "Commit artifacts and open PR."
    actions: |
      Append `LAB7_END` to `logs/lab7.log`. Commit all changes and push.
      Open a pull request targeting `main`.
    done_when: |
      - PR open; all artifacts present.
    log_marker: "LAB7_END"

# FAQ + TROUBLESHOOTING
faq:
  - q: "Where do credentials go?"
    a: "Use env vars, prompts, or Ansible Vault; do not commit passwords. You can reference `ansible_user`/`ansible_password` via vars without storing secrets."
  - q: "network_cli vs httpapi?"
    a: "`network_cli` with `cisco.ios.ios` is fine for this lab. HTTPAPI/NETCONF are covered in other modules."
  - q: "Templates render but deploy fails."
    a: "Ensure snippets are valid IOS-XE syntax and that `ios_config` sends lines in correct order."

tips:
  - title: "Collections mismatch"
    symptom: "Module not found (e.g., ios_config)."
    fix: "Install with `ansible-galaxy collection install -r requirements.yml` and set `ansible_network_os: cisco.ios.ios`."
  - title: "Idempotency noise"
    symptom: "Playbook always reports changes."
    fix: "Make templates deterministic and avoid commands that always change state (e.g., timestamps)."
  - title: "Diff capture"
    symptom: "No diffs written."
    fix: "Run with `--check --diff` and redirect stdout to `data/dryrun/<host>.diff` or use callback plugins."

# GRADING
grading:
  total_points: 75
  rows:
    - { step: "Step 2", requirement: "Dev container ready; Galaxy collections installed (`GALAXY_OK:*`)", points: 8 }
    - { step: "Step 3", requirement: "Project scaffold + ansible.cfg configured (`PROJECT_SCAFFOLD_OK`)", points: 7 }
    - { step: "Step 4", requirement: "Two-device inventory loads (`INVENTORY_OK`)", points: 8 }
    - { step: "Step 5", requirement: "group_vars + host_vars defined (`VARS_OK`)", points: 8 }
    - { step: "Step 6", requirement: "Two Jinja2 templates complete (`TEMPLATES_OK`)", points: 8 }
    - { step: "Step 7", requirement: "Configs rendered for both devices (`RENDER_OK:<host>`)", points: 8 }
    - { step: "Step 8", requirement: "Dry-run diffs captured (`DRYRUN_OK`)", points: 8 }
    - { step: "Step 9", requirement: "Deployed and post-checked on both devices (`DEPLOY_OK`, `POSTCHECK_OK`)", points: 12 }
    - { step: "Step 10", requirement: "Idempotency proven (`IDEMPOTENT_OK`)", points: 6 }
    - { step: "Submission", requirement: "PR open; `LAB7_START`/`LAB7_END`; log hygiene", points: 2 }

# AUTOGRADING
autograder:
  log_path: "logs/lab7.log"
  required_markers:
    - "LAB7_START"
    - "[STEP 2] Dev Container Started"
    - "GALAXY_OK: cisco.ios"
    - "GALAXY_OK: ansible.netcommon"
    - "PROJECT_SCAFFOLD_OK"
    - "INVENTORY_OK"
    - "VARS_OK"
    - "TEMPLATES_OK"
    - "RENDER_OK"
    - "DRYRUN_OK"
    - "DEPLOY_OK"
    - "POSTCHECK_OK"
    - "IDEMPOTENT_OK"
    - "LAB7_END"

# SUBMISSION CHECKLIST
submission_checklist:
  - "Inventory lists Cat8k and Cat9k and connects with `network_cli`."
  - "`group_vars/all.yml` includes shared loopbacks; each host_vars file includes host-specific loopbacks."
  - "Two templates exist and render combined configs to `data/rendered/`."
  - "Dry-run diffs saved to `data/dryrun/`; post-check outputs saved to `data/postcheck/`."
  - "`logs/lab7.log` contains all required markers; PR open to `main`."

license: "© 2025 Sheldon Swanson — Classroom use."