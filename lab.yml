# ==========================================
# Course: Software Defined Networking
# Module: Infrastructure as Code with Ansible
# Purpose: Hands on activity for using Ansible to manage network devices
# Filename: lab.yml
# Author: Sheldon Swanson
# Version: 1.0
# Created: 10/2025
# Updated: 10/2025
# Notes: Parsers ignore these comments.
# ==========================================
title: "Lab 7 — Infrastructure as Code with Ansible"
course: "Software Defined Networking"
module: "Network Automation Fundamentals"
lab_number: 7
time_estimate: "120–150 minutes"

#====================================================
#   ____  _____    _    ____  __  __ _____
#  |  _ \| ____|  / \  |  _ \|  \/  | ____|
#  | |_) |  _|   / _ \ | | | | |\/| |  _|
#  |  _ <| |___ / ___ \| |_| | |  | | |___
#  |_| \_\_____/_/   \_\____/|_|  |_|_____|
#====================================================

repo_tree:
  enabled: true
  max_depth: 3
  ignore:
    - ".git"
    - ".github"
    - "_template"
    - "_render"
    - "__pycache__"
    - ".venv"
    - "venv"
    - "node_modules"
    - ".vscode"
    - ".idea"
    - "*.pyc"
    - "logs"
    - "screens"

readme_topic:
  - title: "Introduction to Ansible"
    content: |
      Ansible is an open-source automation tool that simplifies the management and configuration of
      network devices and IT infrastructure. It uses a simple, human-readable language (YAML) to
      describe automation tasks in playbooks. Ansible operates in an agentless manner, connecting
      to devices over SSH or APIs, making it easy to deploy and manage configurations across
      multiple devices simultaneously.

      Key features of Ansible include:
      - **Idempotency**: Ensures that applying the same configuration multiple times results in the
        same state without unintended changes.
      - **Extensibility**: Supports a wide range of modules for different platforms, including
        network devices from vendors like Cisco, Juniper, and Arista.
      - **Inventory Management**: Allows users to define groups of hosts and their variables in
        inventory files.
      - **Templates**: Uses Jinja2 templating to create dynamic configuration files based on
        variables.
      - **Playbooks**: YAML files that define a series of tasks to be executed on specified hosts.

      Ansible is widely used in network automation for tasks such as configuration management,
      software updates, and network provisioning, enabling network engineers to automate repetitive
      tasks and improve operational efficiency.

  - title: "Ansible Project Structure"
    content: | 
      An Ansible project typically follows a structured directory layout to organize playbooks,
      inventories, variables, templates, and other related files. A common structure includes:

      This structure helps maintain clarity and organization, making it easier to manage complex
      automation tasks across multiple devices and environments.

    code_block:
      language: "bash"
      code: |
        ansible.cfg               # Configuration file for Ansible settings
        inventory.yml             # Inventory file defining hosts and groups
        group_vars/               # Directory for group-specific variables
            all.yml               # Variables applied to all hosts
            routers.yml           # Variables specific to router group
        host_vars/                # Directory for host-specific variables
            router1.yml           # Variables specific to router1
        templates/                # Directory for Jinja2 templates
            vlans.j2              # Template for VLAN configuration
            loopbacks.j2          # Template for Loopback interfaces
        playbooks/                # Directory for Ansible playbooks
            test_connectivity.yml  # Playbook to test connectivity and gather facts
            configure_vlans.yml    # Playbook to configure VLANs
            configure_loopbacks.yml # Playbook to configure Loopback interfaces
            backup_config.yml       # Playbook to backup device configurations
            deploy_all.yml          # Master playbook to run all tasks
        configs/                  # Directory for generated configuration files
        backups/                  # Directory for device configuration backups
        logs/                     # Directory for log files

    code_notes: |
      - `ansible.cfg`: Configures Ansible settings such as inventory location and callback plugins.
      - `inventory.yml`: Defines the network devices to be managed, organized into groups.
      - `group_vars/`: Contains YAML files with variables that apply to specific groups of hosts.
      - `host_vars/`: Contains YAML files with variables that apply to individual hosts.
      - `templates/`: Stores Jinja2 templates used to generate device configurations dynamically.
      - `playbooks/`: Contains YAML files that define the automation tasks to be executed on the hosts.
      - `configs/`: Directory where rendered configuration files from templates are stored.
      - `backups/`: Directory for storing backups of device configurations, typically with timestamps.
      - `logs/`: Directory for log files that capture the output and status of playbook executions.

  - title: "The Ansible Configuration File (ansible.cfg)"
    content: |
      The `ansible.cfg` file is the main configuration file for Ansible, allowing users to customize
      various settings that affect how Ansible operates. It can be placed in the project root,
      user's home directory, or system-wide. Key sections and options include:

      - **[defaults]**: Contains general settings such as inventory file location, remote user,
        and callback plugins.
      - **[privilege_escalation]**: Configures settings for privilege escalation methods like sudo.
      - **[ssh_connection]**: Manages SSH connection parameters, including control paths and timeouts.
      - **[paramiko_connection]**: Settings specific to Paramiko SSH connections.
      - **[logging]**: Defines log file location and format for Ansible's logging output.

      Example `ansible.cfg` content:

    code_block:
      language: "ini"
      code: |
        [defaults]
        inventory = ./inventory.yml
        host_key_checking = False
        callback_whitelist = yaml # Enables YAML output for better readability
        [privilege_escalation]
        become = True
        become_method = enable
        become_user = root
        [ssh_connection]
        control_path = %(directory)s/%%h-%%r
        [logging]
        log_path = ./logs/ansible.log
        log_level = info
    code_notes: |
      - `inventory`: Specifies the path to the inventory file.
      - `host_key_checking`: Disables SSH host key checking for easier connectivity to new hosts.
      - `callback_whitelist`: Enables specific callback plugins, such as YAML for cleaner output.
      - `become`, `become_method`, `become_user`: Configure privilege escalation settings.
      - `control_path`: Defines the SSH control path for connection reuse.
      - `log_path`, `log_level`: Set the location and verbosity of Ansible logs.

  - title: "The Inventory File (inventory.yml)"
    content: |
      The `inventory.yml` file is a crucial component of Ansible, as it defines the hosts and groups
      of hosts on which automation tasks will be executed. The inventory can be static (defined in
      a YAML file) or dynamic (generated by an external script or plugin). Key elements include:

      - **Hosts**: Individual machines or devices managed by Ansible, identified by their IP address
        or hostname.
      - **Groups**: Collections of hosts that share common characteristics, allowing for easier
        management and targeting of tasks.
      - **Variables**: Host-specific or group-specific variables that customize the behavior of
        playbooks and roles.

      Example `inventory.yml` content:

    code_block:
      language: "yaml"
      code: |
        all:
          children:
            switches:
              hosts:
                switch1:
                  ansible_host: 192.0.2.1
                  ansible_user: admin
                  ansible_password: password
                switch2:
                  ansible_host: 192.0.2.2
                  ansible_user: admin
                  ansible_password: password
            routers:
              hosts:
                router1:
                  ansible_host: 192.0.2.3
                  ansible_user: admin
                  ansible_password: password
                router2:
                  ansible_host: 192.0.2.4
                  ansible_user: admin
                  ansible_password: password
    code_notes: |
      - `all`: The top-level group that includes all hosts.
      - `children`: Defines sub-groups within the inventory.
      - `hosts`: Lists individual hosts and their connection details.
      - `ansible_host`, `ansible_user`, `ansible_password`: Connection parameters for each host.

  - title: "Host Variables `host_vars/`"
    content: |
      The `host_vars/` directory is used to define variables that are specific to individual hosts.
      This allows for greater customization and flexibility in playbooks and roles. Each file in
      this directory should be named after the corresponding host and contain valid YAML.

      Example `host_vars/switch1.yml` content:

    code_block:
      language: "yaml"
      code: |
        ansible_host: 192.0.2.1
        ansible_user: admin
        ansible_password: password
    code_notes: |
      - Each file in `host_vars/` corresponds to a specific host.
      - Variables defined here override those in the inventory file.
      - This is useful for host-specific configurations or credentials.

  - title: "Group Variables `group_vars/`"
    content: |
      The `group_vars/` directory is used to define variables that are specific to groups of hosts.
      This allows for easier management of common settings across multiple hosts. Each file in
      this directory should be named after the corresponding group and contain valid YAML.

      Example `group_vars/switches.yml` content:

    code_block:
      language: "yaml"
      code: |
        ansible_host: 192.0.2.1
        ansible_user: admin
        ansible_password: password
    code_notes: |
      - Each file in `group_vars/` corresponds to a specific group.
      - Variables defined here override those in the inventory file.
      - This is useful for group-specific configurations or credentials.

  - title: "Jinja2 Templates"
    content: |
      Jinja2 is a powerful templating engine used in Ansible to create dynamic configuration files
      based on variables. Templates are stored in the `templates/` directory and typically have a
      `.j2` file extension. They allow for the inclusion of logic, loops, and conditionals to
      generate configurations tailored to specific hosts or groups.

      Example `templates/switch_config.j2` content:

    code_block:
      language: "jinja2"
      code: |
        hostname {{ inventory_hostname }}
        interface Vlan{{ vlan_id }}
          ip address {{ ip_address }} {{ subnet_mask }}
        !
        router ospf 1
          network {{ network }} area 0
        !
    code_notes: |
      - `{{ }}`: Used to insert variables into the template.
      - `{% %}`: Used for control structures like loops and conditionals.
      - Templates can be rendered using the `template` module in playbooks to generate
        configuration files that are then applied to devices.

  - title: "Ansible Galaxy Collections"
    content: |
      Ansible Galaxy is a repository for Ansible roles and collections, which are pre-packaged
      sets of modules, plugins, and roles that extend Ansible's functionality. Collections are
      particularly useful for managing specific platforms or technologies, such as network devices.

      To use a collection, you first need to install it using the `ansible-galaxy` command. For
      example, to install the Cisco IOS collection, you would run:

      ```bash
      ansible-galaxy collection install cisco.ios
      ```

      Once installed, you can use the modules provided by the collection in your playbooks.
      For example, the `cisco.ios.ios_config` module can be used to manage configurations on
      Cisco IOS devices.

      Example playbook snippet using a collection module:

    code_block:
      language: "yaml"
      code: |
        - name: Configure VLANs on Cisco IOS devices
          hosts: switches
          gather_facts: no
          tasks:
            - name: Apply VLAN configuration
              cisco.ios.ios_config:
                lines:
                  - vlan {{ item.id }}
                  - name {{ item.name }}
                with_items: "{{ vlans }}"
    code_notes: |
      - Collections group related modules and plugins for specific platforms.
      - Using collections simplifies playbook development by providing ready-to-use functionality.
      - Always check for the latest version of a collection to ensure compatibility and access to
        new features.


#========================================================================
#
#   ___ _   _ ____ _____ ____  _   _  ____ _____ ___ ___  _   _ ____
#  |_ _| \ | / ___|_   _|  _ \| | | |/ ___|_   _|_ _/ _ \| \ | / ___|
#   | ||  \| \___ \ | | | |_) | | | | |     | |  | | | | |  \| \___ \
#   | || |\  |___) || | |  _ <| |_| | |___  | |  | | |_| | |\  |___) |
#  |___|_| \_|____/ |_| |_| \_\\___/ \____| |_| |___\___/|_| \_|____/
#
#========================================================================

objectives:
  - "Create and configure Ansible inventories for network devices."
  - "Test connectivity and gather facts from Cisco devices (DevNet Always-On)."
  - "Organize data with host_vars and group_vars for clean variable scope."
  - "Author Jinja2 templates to generate VLAN and loopback configs."
  - "Build playbooks to configure VLANs and loopbacks from structured data."
  - "Implement a backup playbook that saves device configurations locally."
  - "Apply Infrastructure as Code (IaC) principles for scalable network automation."

python_version: "3.11"
accounts: ["GitHub"]
devices:
  - "Cisco DevNet Always-On Sandbox — Catalyst 8k or 9k (SSH/NETCONF)"

overview: >
  Move from script-based automation to **Infrastructure as Code** with Ansible. You’ll define a
  project with inventories, variables, templates, and playbooks; connect to a DevNet sandbox
  device; deploy VLANs and loopbacks via Jinja2; and implement a timestamped backup workflow.
  The result is idempotent, version-controlled automation you can scale and reuse.

before_you_begin: >
  Open the dev container; verify Ansible and Python are available. Create the folders `logs/`,
  `backups/`, `templates/`, `group_vars/`, `host_vars/`, `playbooks/`, and `configs/` if missing.

resources:
  - { title: "Ansible Documentation", url: "https://docs.ansible.com/" }
  - { title: "Ansible Galaxy — cisco.ios", url: "https://galaxy.ansible.com/cisco/ios" }
  - { title: "Jinja2 Templates", url: "https://jinja.palletsprojects.com/" }
  - { title: "YAML Syntax (YAML.org)", url: "https://yaml.org/spec/" }
  - { title: "Cisco DevNet Sandboxes", url: "https://developer.cisco.com/site/sandbox/" }

faq:
  - q: "Playbook fails with unreachable or SSH auth errors."
    a: "Verify inventory credentials, test manual SSH first, and set host_key_checking False in ansible.cfg."
  - q: "YAML parsing errors on playbooks or vars."
    a: "Use spaces (not tabs), quote strings with colons, and run `yamllint` locally."
  - q: "Templates render but variables are empty."
    a: "Check variable scope and names; test with `ansible-inventory --host <name>` and `debug` tasks."
  - q: "Module `cisco.ios.ios_config` not found."
    a: "Install the collection: `ansible-galaxy collection install cisco.ios` and verify with `ansible-galaxy collection list`."

deliverables:
  readme_summary: "Standardized README with objectives, overview, grading, and tips."
  instructions_summary: "Stepwise INSTRUCTIONS for inventory, templates, playbooks, backups, and logs."
  files:
    root:
      - "ansible.cfg"
      - "inventory.yml"
    vars:
      - "group_vars/all.yml"
      - "group_vars/routers.yml"
      - "host_vars/router1.yml"
    templates:
      - "templates/vlans.j2"
      - "templates/loopbacks.j2"
    playbooks:
      - "playbooks/test_connectivity.yml"
      - "playbooks/configure_vlans.yml"
      - "playbooks/configure_loopbacks.yml"
      - "playbooks/backup_config.yml"
      - "playbooks/deploy_all.yml"
    generated:
      - "configs/<inventory_hostname>_vlans.cfg"
      - "configs/<inventory_hostname>_loopbacks.cfg"
      - "backups/<inventory_hostname>_config_YYYYMMDD_HHMMSS.txt"
      - "backups/backup_log.txt"
    logs:
      - "logs/setup.log"
      - "logs/ansible_test.log"
      - "logs/vlan_deployment.log"
      - "logs/loopback_deployment.log"
      - "logs/backup_operations.log"

grading:
  total_points: 100
  rows:
    - { step: "Environment Setup", requirement: "Dev container functional; Ansible installed", points: 8 }
    - { step: "Inventory & Config", requirement: "Valid ansible.cfg and inventory.yml", points: 10 }
    - { step: "Connectivity Testing", requirement: "Ping + facts gathering succeed", points: 10 }
    - { step: "Variable Structure", requirement: "Correct group_vars and host_vars organization", points: 12 }
    - { step: "Jinja2 Templates", requirement: "Working VLAN and loopback templates", points: 15 }
    - { step: "VLAN Deployment", requirement: "VLAN configuration applied and verified", points: 12 }
    - { step: "Loopback Deployment", requirement: "Loopbacks applied and verified", points: 12 }
    - { step: "Backup Implementation", requirement: "Timestamped backups and logs", points: 15 }
    - { step: "Logging & Docs", requirement: "All required log entries and structure", points: 8 }
    - { step: "Code Quality", requirement: "Clean YAML, commits, and error handling", points: 8 }

tips:
  - title: "Inventory sanity"
    symptom: "Ping fails to all hosts"
    fix: "Run `ansible-inventory --list` and confirm `ansible_host`, user, and connection vars."
  - title: "Template paths"
    symptom: "template not found"
    fix: "Use paths relative to the playbook (`../templates/*.j2`) or set `template` task paths carefully."
  - title: "Privilege issues"
    symptom: "Auth failed when applying configs"
    fix: "Ensure device user has privileges; set `ansible_become: yes` if needed."

autograder:
  log_path: "logs/*.log"
  required_markers:
    - "LAB7_START"
    - "DEVCONTAINER_READY"
    - "INVENTORY_CREATED"
    - "CONNECTIVITY_TEST"
    - "VARIABLES_CREATED"
    - "VLAN_DEPLOYED"
    - "LOOPBACK_DEPLOYED"
    - "BACKUP_CREATED"
    - "LAB7_COMPLETE"

submission_checklist:
  - "ansible.cfg and inventory.yml exist and validate."
  - "group_vars and host_vars load correctly for router1."
  - "templates render without errors and produce device configs under configs/."
  - "playbooks run without tracebacks; VLANs and loopbacks verified via show commands."
  - "backups directory contains timestamped config files; backup_log.txt updated."
  - "all required logs exist with specified markers."
  - "README and INSTRUCTIONS rendered from template; PR passes Verify Docs."

steps:
  - title: "Clone repository and setup"
    goal: "Get the lab locally and initialize logs."
    actions: |
      Clone your Classroom repo and change into it. Ensure `logs/` exists and write an initial
      `LAB7_START` line into `logs/setup.log`.
    done_when: |
      - You are in the repo root.
      - `logs/setup.log` contains `LAB7_START`.
    log_marker: "LAB7_START"

  - title: "Open dev container and verify"
    goal: "Use the standardized environment with Ansible and collections."
    actions: |
      Reopen in container. Verify Ansible version (2.14+), confirm `cisco.ios` is installed,
      and log a `DEVCONTAINER_READY` line with version info to `logs/setup.log`.
    done_when: |
      - Ansible version prints successfully.
      - `logs/setup.log` shows `DEVCONTAINER_READY ...`.
    log_marker: "DEVCONTAINER_READY"

  - title: "Create inventory and ansible.cfg"
    goal: "Target the DevNet sandbox device."
    actions: |
      Create `ansible.cfg` with local inventory path, disabled host key checking, and YAML callback.
      Create `inventory.yml` with a `routers` group and `router1` host using sandbox details.
      Run `ansible-inventory --list` and a simple `ansible all -m ping`.
    done_when: |
      - Inventory lists hosts.
      - Ping succeeds to router1.
      - `logs/ansible_test.log` records `INVENTORY_CREATED`.
    log_marker: "INVENTORY_CREATED"

  - title: "Connectivity test and facts"
    goal: "Validate access and capture device facts."
    actions: |
      Author `playbooks/test_connectivity.yml` to ping and gather facts using `cisco.ios.ios_facts`,
      then append a `CONNECTIVITY_TEST` line to `logs/ansible_test.log`.
    done_when: |
      - Playbook finishes successfully and prints model/version.
      - Log shows `CONNECTIVITY_TEST` entries.
    log_marker: "CONNECTIVITY_TEST"

  - title: "Variable structure (group_vars and host_vars)"
    goal: "Centralize shared data and per-host overrides."
    actions: |
      Create `group_vars/all.yml` and `group_vars/routers.yml` for global and router-group data
      (e.g., DNS/NTP, default VLANs, standard loopbacks). Create `host_vars/router1.yml` for
      device-specific loopbacks and VLANs. Verify access with `ansible-inventory --host router1`.
    done_when: |
      - Files exist with valid YAML.
      - `logs/ansible_test.log` has `VARIABLES_CREATED`.
    log_marker: "VARIABLES_CREATED"

  - title: "Jinja2 templates"
    goal: "Generate VLAN and loopback configs from variables."
    actions: |
      Create `templates/vlans.j2` and `templates/loopbacks.j2`. Dry-run render via a small test
      play to write outputs under `./configs/`.
    done_when: |
      - Both templates render.
      - Generated files contain data from group and host vars.
    log_marker: "TEMPLATES_OK"

  - title: "Deploy VLAN configuration"
    goal: "Apply VLANs and verify on device."
    actions: |
      Create `playbooks/configure_vlans.yml` to render template to `configs/` and apply with
      `cisco.ios.ios_config`. Verify via `show vlan brief` and log `VLAN_DEPLOYED`.
    done_when: |
      - VLANs appear on device.
      - `logs/vlan_deployment.log` shows `VLAN_DEPLOYED`.
    log_marker: "VLAN_DEPLOYED"

  - title: "Deploy loopback interfaces"
    goal: "Apply loopbacks and verify."
    actions: |
      Create `playbooks/configure_loopbacks.yml` to render and apply Loopback interfaces, verify
      with `show ip interface brief | include Loopback`, and log `LOOPBACK_DEPLOYED`.
    done_when: |
      - Loopbacks appear on device.
      - `logs/loopback_deployment.log` shows `LOOPBACK_DEPLOYED`.
    log_marker: "LOOPBACK_DEPLOYED"

  - title: "Backup device configuration"
    goal: "Save timestamped running config and summarize."
    actions: |
      Create `playbooks/backup_config.yml` to write device backups into `backups/` with a timestamp
      and update `backups/backup_log.txt`. Log `BACKUP_CREATED` to `logs/backup_operations.log`.
    done_when: |
      - Backup files exist with timestamps.
      - `backup_log.txt` updated.
      - `logs/backup_operations.log` shows `BACKUP_CREATED`.
    log_marker: "BACKUP_CREATED"

  - title: "Master run and submit"
    goal: "Execute end-to-end and finalize."
    actions: |
      Create `playbooks/deploy_all.yml` that imports the other playbooks. Run it, confirm device
      state matches rendered configs, and add a final `LAB7_COMPLETE` line with counts.
      Commit all files, push, and open a PR to `main`.
    done_when: |
      - All playbooks execute without errors.
      - Required artifacts and logs exist.
      - PR opens and Verify Docs is green.
    log_marker: "LAB7_COMPLETE"

license: "© 2025 Your Name — Classroom use."

